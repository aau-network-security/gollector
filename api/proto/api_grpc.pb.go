// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MeasurementApiClient is the client API for MeasurementApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MeasurementApiClient interface {
	StartMeasurement(ctx context.Context, in *Meta, opts ...grpc.CallOption) (*StartMeasurementResponse, error)
	StopMeasurement(ctx context.Context, in *MeasurementId, opts ...grpc.CallOption) (*Empty, error)
	StartStage(ctx context.Context, in *MeasurementId, opts ...grpc.CallOption) (*Empty, error)
	StopStage(ctx context.Context, in *MeasurementId, opts ...grpc.CallOption) (*Empty, error)
}

type measurementApiClient struct {
	cc grpc.ClientConnInterface
}

func NewMeasurementApiClient(cc grpc.ClientConnInterface) MeasurementApiClient {
	return &measurementApiClient{cc}
}

func (c *measurementApiClient) StartMeasurement(ctx context.Context, in *Meta, opts ...grpc.CallOption) (*StartMeasurementResponse, error) {
	out := new(StartMeasurementResponse)
	err := c.cc.Invoke(ctx, "/MeasurementApi/StartMeasurement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *measurementApiClient) StopMeasurement(ctx context.Context, in *MeasurementId, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/MeasurementApi/StopMeasurement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *measurementApiClient) StartStage(ctx context.Context, in *MeasurementId, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/MeasurementApi/StartStage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *measurementApiClient) StopStage(ctx context.Context, in *MeasurementId, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/MeasurementApi/StopStage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeasurementApiServer is the server API for MeasurementApi service.
// All implementations must embed UnimplementedMeasurementApiServer
// for forward compatibility
type MeasurementApiServer interface {
	StartMeasurement(context.Context, *Meta) (*StartMeasurementResponse, error)
	StopMeasurement(context.Context, *MeasurementId) (*Empty, error)
	StartStage(context.Context, *MeasurementId) (*Empty, error)
	StopStage(context.Context, *MeasurementId) (*Empty, error)
	mustEmbedUnimplementedMeasurementApiServer()
}

// UnimplementedMeasurementApiServer must be embedded to have forward compatible implementations.
type UnimplementedMeasurementApiServer struct {
}

func (UnimplementedMeasurementApiServer) StartMeasurement(context.Context, *Meta) (*StartMeasurementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartMeasurement not implemented")
}
func (UnimplementedMeasurementApiServer) StopMeasurement(context.Context, *MeasurementId) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopMeasurement not implemented")
}
func (UnimplementedMeasurementApiServer) StartStage(context.Context, *MeasurementId) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartStage not implemented")
}
func (UnimplementedMeasurementApiServer) StopStage(context.Context, *MeasurementId) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopStage not implemented")
}
func (UnimplementedMeasurementApiServer) mustEmbedUnimplementedMeasurementApiServer() {}

// UnsafeMeasurementApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MeasurementApiServer will
// result in compilation errors.
type UnsafeMeasurementApiServer interface {
	mustEmbedUnimplementedMeasurementApiServer()
}

func RegisterMeasurementApiServer(s grpc.ServiceRegistrar, srv MeasurementApiServer) {
	s.RegisterService(&MeasurementApi_ServiceDesc, srv)
}

func _MeasurementApi_StartMeasurement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Meta)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementApiServer).StartMeasurement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MeasurementApi/StartMeasurement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementApiServer).StartMeasurement(ctx, req.(*Meta))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeasurementApi_StopMeasurement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MeasurementId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementApiServer).StopMeasurement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MeasurementApi/StopMeasurement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementApiServer).StopMeasurement(ctx, req.(*MeasurementId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeasurementApi_StartStage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MeasurementId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementApiServer).StartStage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MeasurementApi/StartStage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementApiServer).StartStage(ctx, req.(*MeasurementId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeasurementApi_StopStage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MeasurementId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementApiServer).StopStage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MeasurementApi/StopStage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementApiServer).StopStage(ctx, req.(*MeasurementId))
	}
	return interceptor(ctx, in, info, handler)
}

// MeasurementApi_ServiceDesc is the grpc.ServiceDesc for MeasurementApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MeasurementApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "MeasurementApi",
	HandlerType: (*MeasurementApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartMeasurement",
			Handler:    _MeasurementApi_StartMeasurement_Handler,
		},
		{
			MethodName: "StopMeasurement",
			Handler:    _MeasurementApi_StopMeasurement_Handler,
		},
		{
			MethodName: "StartStage",
			Handler:    _MeasurementApi_StartStage_Handler,
		},
		{
			MethodName: "StopStage",
			Handler:    _MeasurementApi_StopStage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// CtApiClient is the client API for CtApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CtApiClient interface {
	StoreLogEntries(ctx context.Context, opts ...grpc.CallOption) (CtApi_StoreLogEntriesClient, error)
	GetLastDBEntry(ctx context.Context, in *KnownLogURL, opts ...grpc.CallOption) (*Index, error)
}

type ctApiClient struct {
	cc grpc.ClientConnInterface
}

func NewCtApiClient(cc grpc.ClientConnInterface) CtApiClient {
	return &ctApiClient{cc}
}

func (c *ctApiClient) StoreLogEntries(ctx context.Context, opts ...grpc.CallOption) (CtApi_StoreLogEntriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &CtApi_ServiceDesc.Streams[0], "/CtApi/StoreLogEntries", opts...)
	if err != nil {
		return nil, err
	}
	x := &ctApiStoreLogEntriesClient{stream}
	return x, nil
}

type CtApi_StoreLogEntriesClient interface {
	Send(*LogEntryBatch) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type ctApiStoreLogEntriesClient struct {
	grpc.ClientStream
}

func (x *ctApiStoreLogEntriesClient) Send(m *LogEntryBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *ctApiStoreLogEntriesClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ctApiClient) GetLastDBEntry(ctx context.Context, in *KnownLogURL, opts ...grpc.CallOption) (*Index, error) {
	out := new(Index)
	err := c.cc.Invoke(ctx, "/CtApi/GetLastDBEntry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CtApiServer is the server API for CtApi service.
// All implementations must embed UnimplementedCtApiServer
// for forward compatibility
type CtApiServer interface {
	StoreLogEntries(CtApi_StoreLogEntriesServer) error
	GetLastDBEntry(context.Context, *KnownLogURL) (*Index, error)
	mustEmbedUnimplementedCtApiServer()
}

// UnimplementedCtApiServer must be embedded to have forward compatible implementations.
type UnimplementedCtApiServer struct {
}

func (UnimplementedCtApiServer) StoreLogEntries(CtApi_StoreLogEntriesServer) error {
	return status.Errorf(codes.Unimplemented, "method StoreLogEntries not implemented")
}
func (UnimplementedCtApiServer) GetLastDBEntry(context.Context, *KnownLogURL) (*Index, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastDBEntry not implemented")
}
func (UnimplementedCtApiServer) mustEmbedUnimplementedCtApiServer() {}

// UnsafeCtApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CtApiServer will
// result in compilation errors.
type UnsafeCtApiServer interface {
	mustEmbedUnimplementedCtApiServer()
}

func RegisterCtApiServer(s grpc.ServiceRegistrar, srv CtApiServer) {
	s.RegisterService(&CtApi_ServiceDesc, srv)
}

func _CtApi_StoreLogEntries_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CtApiServer).StoreLogEntries(&ctApiStoreLogEntriesServer{stream})
}

type CtApi_StoreLogEntriesServer interface {
	Send(*Result) error
	Recv() (*LogEntryBatch, error)
	grpc.ServerStream
}

type ctApiStoreLogEntriesServer struct {
	grpc.ServerStream
}

func (x *ctApiStoreLogEntriesServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *ctApiStoreLogEntriesServer) Recv() (*LogEntryBatch, error) {
	m := new(LogEntryBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CtApi_GetLastDBEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KnownLogURL)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CtApiServer).GetLastDBEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/CtApi/GetLastDBEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CtApiServer).GetLastDBEntry(ctx, req.(*KnownLogURL))
	}
	return interceptor(ctx, in, info, handler)
}

// CtApi_ServiceDesc is the grpc.ServiceDesc for CtApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CtApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CtApi",
	HandlerType: (*CtApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLastDBEntry",
			Handler:    _CtApi_GetLastDBEntry_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StoreLogEntries",
			Handler:       _CtApi_StoreLogEntries_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

// ZoneFileApiClient is the client API for ZoneFileApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ZoneFileApiClient interface {
	StoreZoneEntry(ctx context.Context, opts ...grpc.CallOption) (ZoneFileApi_StoreZoneEntryClient, error)
}

type zoneFileApiClient struct {
	cc grpc.ClientConnInterface
}

func NewZoneFileApiClient(cc grpc.ClientConnInterface) ZoneFileApiClient {
	return &zoneFileApiClient{cc}
}

func (c *zoneFileApiClient) StoreZoneEntry(ctx context.Context, opts ...grpc.CallOption) (ZoneFileApi_StoreZoneEntryClient, error) {
	stream, err := c.cc.NewStream(ctx, &ZoneFileApi_ServiceDesc.Streams[0], "/ZoneFileApi/StoreZoneEntry", opts...)
	if err != nil {
		return nil, err
	}
	x := &zoneFileApiStoreZoneEntryClient{stream}
	return x, nil
}

type ZoneFileApi_StoreZoneEntryClient interface {
	Send(*ZoneEntryBatch) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type zoneFileApiStoreZoneEntryClient struct {
	grpc.ClientStream
}

func (x *zoneFileApiStoreZoneEntryClient) Send(m *ZoneEntryBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *zoneFileApiStoreZoneEntryClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ZoneFileApiServer is the server API for ZoneFileApi service.
// All implementations must embed UnimplementedZoneFileApiServer
// for forward compatibility
type ZoneFileApiServer interface {
	StoreZoneEntry(ZoneFileApi_StoreZoneEntryServer) error
	mustEmbedUnimplementedZoneFileApiServer()
}

// UnimplementedZoneFileApiServer must be embedded to have forward compatible implementations.
type UnimplementedZoneFileApiServer struct {
}

func (UnimplementedZoneFileApiServer) StoreZoneEntry(ZoneFileApi_StoreZoneEntryServer) error {
	return status.Errorf(codes.Unimplemented, "method StoreZoneEntry not implemented")
}
func (UnimplementedZoneFileApiServer) mustEmbedUnimplementedZoneFileApiServer() {}

// UnsafeZoneFileApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ZoneFileApiServer will
// result in compilation errors.
type UnsafeZoneFileApiServer interface {
	mustEmbedUnimplementedZoneFileApiServer()
}

func RegisterZoneFileApiServer(s grpc.ServiceRegistrar, srv ZoneFileApiServer) {
	s.RegisterService(&ZoneFileApi_ServiceDesc, srv)
}

func _ZoneFileApi_StoreZoneEntry_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ZoneFileApiServer).StoreZoneEntry(&zoneFileApiStoreZoneEntryServer{stream})
}

type ZoneFileApi_StoreZoneEntryServer interface {
	Send(*Result) error
	Recv() (*ZoneEntryBatch, error)
	grpc.ServerStream
}

type zoneFileApiStoreZoneEntryServer struct {
	grpc.ServerStream
}

func (x *zoneFileApiStoreZoneEntryServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *zoneFileApiStoreZoneEntryServer) Recv() (*ZoneEntryBatch, error) {
	m := new(ZoneEntryBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ZoneFileApi_ServiceDesc is the grpc.ServiceDesc for ZoneFileApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ZoneFileApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ZoneFileApi",
	HandlerType: (*ZoneFileApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StoreZoneEntry",
			Handler:       _ZoneFileApi_StoreZoneEntry_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

// SplunkApiClient is the client API for SplunkApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SplunkApiClient interface {
	StorePassiveEntry(ctx context.Context, opts ...grpc.CallOption) (SplunkApi_StorePassiveEntryClient, error)
}

type splunkApiClient struct {
	cc grpc.ClientConnInterface
}

func NewSplunkApiClient(cc grpc.ClientConnInterface) SplunkApiClient {
	return &splunkApiClient{cc}
}

func (c *splunkApiClient) StorePassiveEntry(ctx context.Context, opts ...grpc.CallOption) (SplunkApi_StorePassiveEntryClient, error) {
	stream, err := c.cc.NewStream(ctx, &SplunkApi_ServiceDesc.Streams[0], "/SplunkApi/StorePassiveEntry", opts...)
	if err != nil {
		return nil, err
	}
	x := &splunkApiStorePassiveEntryClient{stream}
	return x, nil
}

type SplunkApi_StorePassiveEntryClient interface {
	Send(*SplunkEntryBatch) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type splunkApiStorePassiveEntryClient struct {
	grpc.ClientStream
}

func (x *splunkApiStorePassiveEntryClient) Send(m *SplunkEntryBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *splunkApiStorePassiveEntryClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SplunkApiServer is the server API for SplunkApi service.
// All implementations must embed UnimplementedSplunkApiServer
// for forward compatibility
type SplunkApiServer interface {
	StorePassiveEntry(SplunkApi_StorePassiveEntryServer) error
	mustEmbedUnimplementedSplunkApiServer()
}

// UnimplementedSplunkApiServer must be embedded to have forward compatible implementations.
type UnimplementedSplunkApiServer struct {
}

func (UnimplementedSplunkApiServer) StorePassiveEntry(SplunkApi_StorePassiveEntryServer) error {
	return status.Errorf(codes.Unimplemented, "method StorePassiveEntry not implemented")
}
func (UnimplementedSplunkApiServer) mustEmbedUnimplementedSplunkApiServer() {}

// UnsafeSplunkApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SplunkApiServer will
// result in compilation errors.
type UnsafeSplunkApiServer interface {
	mustEmbedUnimplementedSplunkApiServer()
}

func RegisterSplunkApiServer(s grpc.ServiceRegistrar, srv SplunkApiServer) {
	s.RegisterService(&SplunkApi_ServiceDesc, srv)
}

func _SplunkApi_StorePassiveEntry_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SplunkApiServer).StorePassiveEntry(&splunkApiStorePassiveEntryServer{stream})
}

type SplunkApi_StorePassiveEntryServer interface {
	Send(*Result) error
	Recv() (*SplunkEntryBatch, error)
	grpc.ServerStream
}

type splunkApiStorePassiveEntryServer struct {
	grpc.ServerStream
}

func (x *splunkApiStorePassiveEntryServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *splunkApiStorePassiveEntryServer) Recv() (*SplunkEntryBatch, error) {
	m := new(SplunkEntryBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SplunkApi_ServiceDesc is the grpc.ServiceDesc for SplunkApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SplunkApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "SplunkApi",
	HandlerType: (*SplunkApiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StorePassiveEntry",
			Handler:       _SplunkApi_StorePassiveEntry_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

// EntradaApiClient is the client API for EntradaApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EntradaApiClient interface {
	StoreEntradaEntry(ctx context.Context, opts ...grpc.CallOption) (EntradaApi_StoreEntradaEntryClient, error)
	GetOffset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Offset, error)
}

type entradaApiClient struct {
	cc grpc.ClientConnInterface
}

func NewEntradaApiClient(cc grpc.ClientConnInterface) EntradaApiClient {
	return &entradaApiClient{cc}
}

func (c *entradaApiClient) StoreEntradaEntry(ctx context.Context, opts ...grpc.CallOption) (EntradaApi_StoreEntradaEntryClient, error) {
	stream, err := c.cc.NewStream(ctx, &EntradaApi_ServiceDesc.Streams[0], "/EntradaApi/StoreEntradaEntry", opts...)
	if err != nil {
		return nil, err
	}
	x := &entradaApiStoreEntradaEntryClient{stream}
	return x, nil
}

type EntradaApi_StoreEntradaEntryClient interface {
	Send(*EntradaEntryBatch) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type entradaApiStoreEntradaEntryClient struct {
	grpc.ClientStream
}

func (x *entradaApiStoreEntradaEntryClient) Send(m *EntradaEntryBatch) error {
	return x.ClientStream.SendMsg(m)
}

func (x *entradaApiStoreEntradaEntryClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *entradaApiClient) GetOffset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Offset, error) {
	out := new(Offset)
	err := c.cc.Invoke(ctx, "/EntradaApi/GetOffset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EntradaApiServer is the server API for EntradaApi service.
// All implementations must embed UnimplementedEntradaApiServer
// for forward compatibility
type EntradaApiServer interface {
	StoreEntradaEntry(EntradaApi_StoreEntradaEntryServer) error
	GetOffset(context.Context, *Empty) (*Offset, error)
	mustEmbedUnimplementedEntradaApiServer()
}

// UnimplementedEntradaApiServer must be embedded to have forward compatible implementations.
type UnimplementedEntradaApiServer struct {
}

func (UnimplementedEntradaApiServer) StoreEntradaEntry(EntradaApi_StoreEntradaEntryServer) error {
	return status.Errorf(codes.Unimplemented, "method StoreEntradaEntry not implemented")
}
func (UnimplementedEntradaApiServer) GetOffset(context.Context, *Empty) (*Offset, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOffset not implemented")
}
func (UnimplementedEntradaApiServer) mustEmbedUnimplementedEntradaApiServer() {}

// UnsafeEntradaApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EntradaApiServer will
// result in compilation errors.
type UnsafeEntradaApiServer interface {
	mustEmbedUnimplementedEntradaApiServer()
}

func RegisterEntradaApiServer(s grpc.ServiceRegistrar, srv EntradaApiServer) {
	s.RegisterService(&EntradaApi_ServiceDesc, srv)
}

func _EntradaApi_StoreEntradaEntry_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EntradaApiServer).StoreEntradaEntry(&entradaApiStoreEntradaEntryServer{stream})
}

type EntradaApi_StoreEntradaEntryServer interface {
	Send(*Result) error
	Recv() (*EntradaEntryBatch, error)
	grpc.ServerStream
}

type entradaApiStoreEntradaEntryServer struct {
	grpc.ServerStream
}

func (x *entradaApiStoreEntradaEntryServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *entradaApiStoreEntradaEntryServer) Recv() (*EntradaEntryBatch, error) {
	m := new(EntradaEntryBatch)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EntradaApi_GetOffset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EntradaApiServer).GetOffset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/EntradaApi/GetOffset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EntradaApiServer).GetOffset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// EntradaApi_ServiceDesc is the grpc.ServiceDesc for EntradaApi service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EntradaApi_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "EntradaApi",
	HandlerType: (*EntradaApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOffset",
			Handler:    _EntradaApi_GetOffset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StoreEntradaEntry",
			Handler:       _EntradaApi_StoreEntradaEntry_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}
